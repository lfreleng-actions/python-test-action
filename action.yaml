---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# python-test-action
name: 'üß™ Python Test'
description: 'Test a Python Project, generate coverage report'

inputs:
  # Mandatory
  python_version:
    # A matrix Python build version should be passed as input
    description: 'Python version used to run test'
    required: true
    # type: string
  # Optional
  editable:
    description: 'Install Python package in editable mode'
    required: false
    # type: boolean
    default: 'false'
  permit_fail:
    description: 'Continue even when one or more tests fails'
    required: false
    # type: boolean
    default: 'false'
  report_artefact:
    description: 'Uploads test/coverage report bundle as artefact'
    required: false
    # type: boolean
    default: 'true'
  artefact_name:
    description: 'Custom name for uploaded artefact (to avoid conflicts)'
    required: false
    # type: string
  path_prefix:
    description: 'Directory location containing Python project code'
    # type: string
    required: false
    default: '.'
  tests_path:
    description: 'Path relative to the project folder containing tests'
    required: false
    # type: string
  tox_tests:
    description: 'Uses tox to perform tests'
    required: false
    # type: boolean
    default: 'false'
  tox_envs:
    description: 'Space separated list of tox environments to run'
    required: false
    # type: string
  github_token:
    description: 'GitHub token for API access during tests'
    required: false
    # type: string
  pytest_args:
    description: 'Additional pytest arguments (e.g., -n0 for serial execution)'
    required: false
    # type: string
    default: ''

runs:
  using: 'composite'
  steps:
    - name: 'Setup action/environment'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        # Setup action/environment

        # Helper function to validate boolean inputs (case-insensitive)
        validate_boolean() {
          local input_name="$1"
          local input_value="$2"
          local normalized=$(echo "$input_value" | tr '[:upper:]' '[:lower:]')

          if [ "$normalized" != "true" ] && [ "$normalized" != "false" ]; then
            echo "‚ö†Ô∏è true/false not correctly passed for $input_name"
            echo "‚ö†Ô∏è true/false not correctly passed for $input_name" \
              >> "$GITHUB_STEP_SUMMARY"
            return 1
          fi
          return 0
        }

        # Validate all boolean inputs
        validation_failed=0
        validate_boolean "editable" "${{ inputs.editable }}" \
          || validation_failed=1
        validate_boolean "permit_fail" "${{ inputs.permit_fail }}" \
          || validation_failed=1
        validate_boolean "report_artefact" "${{ inputs.report_artefact }}" \
          || validation_failed=1
        validate_boolean "tox_tests" "${{ inputs.tox_tests }}" \
          || validation_failed=1

        if [ $validation_failed -eq 1 ]; then
          echo 'Error: Invalid boolean input(s) detected ‚ùå'; exit 1
        fi

        # Store normalized boolean values to avoid re-normalizing later
        editable_lower=$(echo "${{ inputs.editable }}" | \
          tr '[:upper:]' '[:lower:]')
        permit_fail_lower=$(echo "${{ inputs.permit_fail }}" | \
          tr '[:upper:]' '[:lower:]')
        report_artefact_lower=$(echo "${{ inputs.report_artefact }}" | \
          tr '[:upper:]' '[:lower:]')
        tox_tests_lower=$(echo "${{ inputs.tox_tests }}" | \
          tr '[:upper:]' '[:lower:]')

        echo "editable_lower=$editable_lower" >> "$GITHUB_ENV"
        echo "permit_fail_lower=$permit_fail_lower" >> "$GITHUB_ENV"
        echo "report_artefact_lower=$report_artefact_lower" >> "$GITHUB_ENV"
        echo "tox_tests_lower=$tox_tests_lower" >> "$GITHUB_ENV"

        if [ -z "${{ inputs.python_version }}" ]; then
          echo 'Error: Python version was not provided ‚ùå'; exit 1
        else
          echo "Using Python: ${{ inputs.python_version }} üêç"
        fi

        # Verify path_prefix is a valid directory path
        if [ ! -d "${{ inputs.path_prefix }}" ]; then
          echo 'Error: invalid path/prefix to project directory ‚ùå'; exit 1
        fi

        # The coverage report location will also use this environment variable
        tox_envs=$(echo "py${{ inputs.python_version }}" | sed 's/\.//g')
        echo "tox_envs=$tox_envs" >> "$GITHUB_ENV"

        # Setup dedicated coverage report directory outside project path
        coverage_dir="/tmp/coverage-$tox_envs"
        mkdir -p "$coverage_dir"
        echo "coverage_dir=$coverage_dir" >> "$GITHUB_ENV"
        echo "Coverage report output location: $coverage_dir üí¨"

        if [ "f$permit_fail_lower" = 'ftrue' ]; then
          echo 'Warning: test failures will be permitted ‚ö†Ô∏è'
        fi

        # Testing with TOX
        if [ "f$tox_tests_lower" = 'ftrue' ]; then
          echo 'Using tox to perform tests üí¨'
          if [ -z "${{ inputs.tox_envs }}" ]; then
            echo 'Using tox environment derived from matrix Python version'
            echo "Using current matrix python version: $tox_envs"
          else
            tox_envs="${{ inputs.tox_envs }}"
            echo "Testing with tox environments: ${{ inputs.tox_envs }} üí¨"
          fi
          echo "tox_envs=$tox_envs" >> "$GITHUB_ENV"
        fi

        # Check/setup test path
        if [ -n "${{ inputs.tests_path }}" ] && \
          [ ! -d "${{ inputs.path_prefix }}/${{ inputs.tests_path }}" ]; then
          echo 'Error: invalid path/prefix to test directory ‚ùå'
          echo "${{ inputs.path_prefix }}/${{ inputs.tests_path }}"; exit 1
        fi
        if [ -n "${{ inputs.tests_path }}" ]; then
          TESTS_PATH="${{ inputs.path_prefix }}/${{ inputs.tests_path }}"
        # Otherwise search/use common locations
        elif [ -d "${{ inputs.path_prefix }}/test" ]; then
          TESTS_PATH="${{ inputs.path_prefix }}/test"
        elif [ -d "${{ inputs.path_prefix }}/tests" ]; then
          TESTS_PATH="${{ inputs.path_prefix }}/tests"
        else
          echo 'Error: could not determine path to tests ‚ùå'; exit 1
        fi
        echo "Tests path: $TESTS_PATH üí¨"
        echo "tests_path=$TESTS_PATH" >> "$GITHUB_ENV"

    - name: 'Validate and sanitize pytest arguments'
      shell: bash
      run: |
        # Validate and sanitize pytest arguments

        # Ring-fence this validation from the rest of the environment
        set -euo pipefail

        pytest_args_input="${{ inputs.pytest_args }}"

        if [ -z "$pytest_args_input" ]; then
          echo "No additional pytest arguments provided"
          echo "VALIDATED_PYTEST_ARGS=" >> "$GITHUB_ENV"
          exit 0
        fi

        echo "Validating pytest arguments: '$pytest_args_input'"

        # Security validation: Check for dangerous characters
        # Allow only: alphanumeric, spaces, hyphens, equals, commas, dots,
        # forward slashes, colons, and underscores
        if echo "$pytest_args_input" | grep -qE '[^a-zA-Z0-9 \-=,\./:_]'; then
          echo "Error: Invalid characters detected in pytest_args ‚ùå"
          echo "Allowed characters: alphanumeric, space, - = , . / : _"
          echo "Provided: '$pytest_args_input'"
          exit 1
        fi

        # Check for command injection patterns
        # Note: Single characters like |, >, <, `, ), {, }
        #   are already blocked by regex
        dangerous_patterns=(
          '&&' '||' ';' '$('
        )

        for pattern in "${dangerous_patterns[@]}"; do
          if echo "$pytest_args_input" | grep -qF "$pattern"; then
            echo "Error: Dangerous pattern '$pattern' detected in pytest_args ‚ùå"
            exit 1
          fi
        done

        # Validate that arguments start with - or -- (pytest flags)
        # or are valid pytest expressions/paths
        # Note: Word splitting on spaces is intentional here to parse
        # individual arguments. Arguments with equals signs (e.g., --maxfail=2)
        # work correctly because they contain no spaces and remain intact as
        # single words.
        validated_args=""
        for arg in $pytest_args_input; do
          # Allow pytest flags (starting with - or --)
          if [[ "$arg" =~ ^--? ]]; then
            validated_args="$validated_args $arg"
          # Allow pytest expressions (e.g., test_name, test_file.py)
          elif [[ "$arg" =~ ^[a-zA-Z0-9_./:-]+$ ]]; then
            validated_args="$validated_args $arg"
          else
            echo "Error: Invalid pytest argument format: '$arg' ‚ùå"
            echo "Check action documentation for further details"
            exit 1
          fi
        done

        # Trim leading/trailing spaces
        validated_args=$(echo "$validated_args" | xargs)

        echo "Validated pytest arguments: '$validated_args' ‚úÖ"
        echo "VALIDATED_PYTEST_ARGS=$validated_args" >> "$GITHUB_ENV"

    - name: 'Setup action/environment (continued)'
      shell: bash
      run: |
        # Setup pip install flags for editable mode
        PIP_EDITABLE_FLAG=""
        if [ "f$editable_lower" = 'ftrue' ]; then
          PIP_EDITABLE_FLAG="-e"
          echo "Installing package in editable mode üí¨"
        else
          echo "Installing package in standard (non-editable) mode üí¨"
        fi
        echo "PIP_EDITABLE_FLAG=$PIP_EDITABLE_FLAG" >> "$GITHUB_ENV"

    - name: 'Check for data_file in pyproject.toml'
      # yamllint disable-line rule:line-length
      uses: lfreleng-actions/file-grep-regex-action@ba13750798b15e6acf23f3342a280ffc8148b950 # v0.1.4
      id: cov-run
      with:
        flags: '-E'
        regex: '^data_file\s*=.*'
        filename: "${{ inputs.path_prefix }}/pyproject.toml"
        no_fail: 'true'

    - name: 'Warning: coverage temporary files'
      if: steps.cov-run.outputs.extracted_string == ''
      shell: bash
      run: |
        # Warning: coverage temporary files
        echo "Warning: coverage report temporary files ‚ö†Ô∏è"
        echo "Tests sensitive to file system content may break"
        echo "Set data_file parameter in pyproject.toml to avoid this warning"

    - name: 'Check for tox configuration file'
      if: inputs.tox_tests == 'true'
      id: tox-config
      # yamllint disable-line rule:line-length
      uses: lfreleng-actions/path-check-action@9606e61c870025bc956e63156d1d55c5df54426c # v0.2.0
      with:
        path: "${{ inputs.path_prefix }}/tox.ini"

    - name: 'Tox configuration file missing'
      # yamllint disable-line rule:line-length
      if: steps.tox-config.outputs.type != 'file' && inputs.tox_tests == 'true'
      shell: bash
      run: |
        # Tox configuration file missing
        echo 'Error: tox configuration file missing ‚ùå'; exit 1

    - name: "Set up Python ${{ inputs.python_version }}"
      # yamllint disable-line rule:line-length
      uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # v6.1.0
      with:
        python-version: "${{ inputs.python_version }}"

    - name: 'Cache Python dependencies'
      # yamllint disable-line rule:line-length
      uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v4.0.2
      with:
        path: |
          ~/.cache/pip
          ~/.cache/pypoetry
          ~/.cache/pipenv
          .venv
          .tox
        # yamllint disable rule:line-length
        key: >-
          python-${{ runner.os }}-${{ inputs.python_version }}-
          ${{ hashFiles('**/requirements*.txt', '**/pyproject.toml', '**/poetry.lock', '**/Pipfile*', '**/setup.py', '**/setup.cfg') }}
        restore-keys: |
          python-${{ runner.os }}-${{ inputs.python_version }}-
          python-${{ runner.os }}-
        # yamllint enable rule:line-length

    - name: 'Performing tests [tox]'
      if: steps.tox-config.outputs.type == 'file' && inputs.tox_tests == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        # Performing tests [tox]
        echo 'Installing: tox ‚¨áÔ∏è'
        # Under Python 3.8, use a compatible tox release, latest for others
        if [[ "${{ inputs.python_version }}" == "3.8" ]]; then
          echo 'Using tox<4.0.0 for Python 3.8 compatibility'
          pip install --disable-pip-version-check -q 'tox<4.0.0'
        else
          echo 'Using latest tox version'
          pip install --disable-pip-version-check -q tox
        fi
        if [ -n "${{ env.tox_envs }}" ]; then
          for ENV in "${{ env.tox_envs }}"; do
            echo "Running: tox -c ${{ inputs.path_prefix }}/tox.ini -e $ENV üí¨"
            tox -c "${{ inputs.path_prefix }}/tox.ini" -e "$ENV"
          done
        else
          echo 'Running: tox -c ${{ inputs.path_prefix }}/tox.ini üí¨'
          tox -c "${{ inputs.path_prefix }}/tox.ini"
        fi

    - name: 'Install project and test/dev dependencies [pytest]'
      if: inputs.tox_tests != 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        # Install project and test/dev dependencies

        # Important note: package installation order matters
        # Install the package (editable or not) before installing test runners
        # (like pytest and coverage) to ensure the latest code is used
        echo 'Install project and test/dev dependencies (before pytest install)'
        if [ -f "${{ inputs.path_prefix }}/pyproject.toml" ]; then
          echo "Source: ${{ inputs.path_prefix }}/pyproject.toml ‚¨áÔ∏è"
          # First try to install with test dependencies
          # Note: ./ prefix is required to indicate local path, otherwise pip
          # interprets the argument as a package name to download from PyPI
          if pip install ${PIP_EDITABLE_FLAG} \
          "./${{ inputs.path_prefix }}[test,dev]"; then
            echo 'Successfully installed test and dev dependencies ‚úÖ'
          elif pip install ${PIP_EDITABLE_FLAG} \
            "./${{ inputs.path_prefix }}[test]"; then
            echo 'Successfully installed test dependencies ‚úÖ'
          else
            echo 'Fallback: installing base package only ‚ö†Ô∏è'
            pip install ${PIP_EDITABLE_FLAG} "./${{ inputs.path_prefix }}"
          fi
        elif [ -f "${{ inputs.path_prefix }}/requirements.txt" ]; then
          echo "Source: ${{ inputs.path_prefix }}/requirements.txt ‚¨áÔ∏è"
          pip install -r "${{ inputs.path_prefix }}/requirements.txt"
        fi

        echo 'Installing: pytest, pytest-cov, coverage[toml] ‚¨áÔ∏è'
        pip install --disable-pip-version-check -q \
          pytest \
          pytest-cov \
          coverage\[toml\]

    - name: 'Run tests and coverage report [pytest]'
      if: inputs.tox_tests != 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        # Tests and coverage report [pytest]

        # Setup XML coverage report for upload as artefact
        if [ "f$report_artefact_lower" = 'ftrue' ]; then
          coverage_flags="--cov-report=term-missing \
          --cov-report=xml:/tmp/coverage-$tox_envs/coverage.xml \
          --cov-config=${{ inputs.path_prefix }}/pyproject.toml"
        else
          coverage_flags=""
        fi

        echo "Running tests in: ${{ env.tests_path }} üß™"
        if [ "f$permit_fail_lower" = 'ftrue' ]; then
          echo 'Warning: flag set to permit test failures ‚ö†Ô∏è'
          # Note: VALIDATED_PYTEST_ARGS is intentionally unquoted to allow word
          # splitting for multiple arguments. This is safe because validation
          # logic ensures only well-formed, safe arguments are present.
          pytest \
            --rootdir="${{ inputs.path_prefix }}" \
            $coverage_flags \
            ${{ env.VALIDATED_PYTEST_ARGS }} \
            ${{ env.tests_path }} || true
        else
          # Note: VALIDATED_PYTEST_ARGS is intentionally unquoted to allow word
          # splitting for multiple arguments. This is safe because validation
          # logic ensures only well-formed, safe arguments are present.
          pytest \
            --rootdir="${{ inputs.path_prefix }}" \
            $coverage_flags \
            ${{ env.VALIDATED_PYTEST_ARGS }} \
            ${{ env.tests_path }}
        fi

    - name: 'Upload test/coverage report'
      # yamllint disable-line rule:line-length
      uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
      if: env.report_artefact_lower == 'true'
      with:
        # yamllint disable-line rule:line-length
        name: "${{ inputs.artefact_name != '' && inputs.artefact_name || format('{0}-coverage.xml', env.tox_envs) }}"
        # yamllint disable-line rule:line-length
        path: "${{ env.coverage_dir }}/coverage.xml"
        retention-days: 90
